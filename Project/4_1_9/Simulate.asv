function Simulate()
    % --- DH Parameters for IRB1200 ---
    dh = struct('d1',399,'a2',350,'a3',42,'d4',351,'d6',82);

    % Start configuration is HOME (all zeros)
    q_home = zeros(6,1);
    [~, origins_home, ~] = forwardKinematics(dh, q_home);
    start_pos = origins_home(:,end)/10;  % in cm
    start_rpy = [0 0 0];  % Home orientation

   

    % --- Path generation ---
    N = 100;
    dt = 0.1;  % seconds between steps

    % Interpolate position
    path_positions = [linspace(start_pos(1), end_pos(1), N);
                       linspace(start_pos(2), end_pos(2), N);
                       linspace(start_pos(3), end_pos(3), N)];

    % Interpolate RPY
    path_rpys = [linspace(start_rpy(1), end_rpy(1), N);
                  linspace(start_rpy(2), end_rpy(2), N);
                  linspace(start_rpy(3), end_rpy(3), N)];

    % --- For storing robot joint angles ---
    joint_trajectory = zeros(6,N);

    % --- Compute IK for all positions ---
    for k = 1:N
        goal_pos_mm = path_positions(:,k) * 10;  % cm -> mm
        sol = InverseKinematics(dh, goal_pos_mm);
        if isempty(sol)
            error('IK failed at step %d', k);
        end
        joint_trajectory(:,k) = sol(:,1);  % pick first solution
    end

    % --- Animate the robot along the path ---
    figure('Name','IRB 1200 Planned Motion','NumberTitle','off');
    ax = axes;
    xlabel(ax, 'X (cm)'); ylabel(ax, 'Y (cm)'); zlabel(ax, 'Z (cm)');
    grid(ax, 'on'); hold(ax, 'on');
    view(ax, 45, 30);

    % --- Store EE positions for velocity calculation ---
    EE_positions = zeros(3,N);

    for k = 1:N
        cla(ax);
        theta_rad = joint_trajectory(:,k);
        [~, origins, rots] = forwardKinematics(dh, theta_rad);

        % Store TCP position
        EE_positions(:,k) = origins(:,end)/10;

        % Plot links
        plot3(ax, origins(1,:)/10, origins(2,:)/10, origins(3,:)/10, '-ok', ...
            'LineWidth', 2, 'MarkerSize', 4);
        hold(ax, 'on');

        % Plot path so far
        plot3(ax, EE_positions(1,1:k), EE_positions(2,1:k), EE_positions(3,1:k), 'b--');

        % Draw coordinate axes
        axisLen = 5;  % cm
        cols3 = {'r','g','b'};
        labels = {'X','Y','Z'};
        for j = 1:size(origins,2)
            O = origins(:,j)/10;
            R = rots(:,:,j);
            for ii = 1:3
                v = R(:,ii) * axisLen;
                line(ax, [O(1), O(1)+v(1)], [O(2), O(2)+v(2)], [O(3), O(3)+v(3)], ...
                    'Color', cols3{ii}, 'LineWidth', 2);
                tip = O + v*1.1;
                text(ax, tip(1), tip(2), tip(3), sprintf('%s%d', labels{ii}, j-1), ...
                    'FontSize', 9, 'FontWeight', 'bold');
            end
        end

        title(ax, sprintf('Step %d/%d', k, N));
        setAxesEqual3D(ax);
        pause(0.01);
    end

    % --- Plot the full 3D path in a new figure ---
    figure('Name','End-Effector Trajectory','NumberTitle','off');
    plot3(EE_positions(1,:), EE_positions(2,:), EE_positions(3,:), 'b', 'LineWidth', 2);
    grid on; axis equal;
    xlabel('X (cm)'); ylabel('Y (cm)'); zlabel('Z (cm)');
    title('End-Effector Path in 3D Space');

    % --- Compute velocity magnitude over time ---
    velocities = vecnorm(diff(EE_positions,1,2)/dt);
    time_vec = dt*(1:(N-1));

    % --- Plot velocity over time ---
    figure('Name','Velocity vs Time','NumberTitle','off');
    plot(time_vec, velocities, 'r', 'LineWidth', 2);
    grid on;
    xlabel('Time (s)');
    ylabel('Velocity (cm/s)');
    title('End-Effector Linear Velocity Magnitude vs Time');
end

function setAxesEqual3D(ax)
    xL = xlim(ax); yL = ylim(ax); zL = zlim(ax);
    xMid = mean(xL); yMid = mean(yL); zMid = mean(zL);
    xRange = diff(xL); yRange = diff(yL); zRange = diff(zL);
    maxRange = max([xRange, yRange, zRange]);
    xlim(ax, [xMid - maxRange/2, xMid + maxRange/2]);
    ylim(ax, [yMid - maxRange/2, yMid + maxRange/2]);
    zlim(ax, [zMid - maxRange/2, zMid + maxRange/2]);
end
